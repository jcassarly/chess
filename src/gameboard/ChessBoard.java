package gameboard;

import helpers.Message;
import helpers.ModalityPanel;
import helpers.Move;
import pieces.Piece;

/**
 *
 * @author Jared Cassarly
 */
public class ChessBoard extends javax.swing.JPanel {
    
    private Square[][] board; // should be 8x8 board alternating colors
    
    private boolean isMoving;
    private Square moving;
    
    private ChessGame parent;
    
    private boolean currentMoveIsWhite;
    
    public ChessBoard() {
        initComponents();
    }

    /**
     * Creates new form ChessBoard
     * @param parent
     */
    public ChessBoard(ChessGame parent) {
        isMoving = false;
        moving = null;
        this.parent = parent;
        this.currentMoveIsWhite = true;
        initComponents();
        initBoard();
    }
    
    /**
     * Returns the 2-dimensional array of Squares that make up the 8x8 board
     * @return the 2-dimensional array of Squares that make up the 8x8 board
     */
    public Square[][] getBoard() {
        return board;
    }
    
    /**
     * Returns whether a piece is selected to move
     * @return true if piece is selected to move, false otherwise
     */
    public boolean isMoving() {
        return isMoving;
    }
    
    /**
     * Returns the selected Square of the piece that is moving
     * @return the selected Square of the selected piece that is moving
     */
    public Square getMoving() {
        return moving;
    }
    
    /**
     * Set what Square holds a moving piece
     * @param s the Square holding a piece that will move
     */
    public void setMoving(Square s) {
        moving = s;
    }
    
    /**
     * Returns the ChessGame object that created this ChessBoard
     * @return the ChessGame object that created this ChessBoard
     */
    public ChessGame getTheParent() {
        return parent;
    }
    
    /**
     * Set what the current move is (white or black)
     * @param isWhite true if the current move is to be set to white, false if black
     */
    public void setCurrentMove(boolean isWhite) {
        currentMoveIsWhite = isWhite;
    }
    
    /**
     * Set which color is currently moving
     * Precondition: isWhite is either 0 or 1
     * @param isWhite If white is moving, isWhite should equal 1, else black is moving and isWhite should equal 0 to signify false
     */
    public void setCurrentMove(int isWhite) {
        switch (isWhite) {
            // if black is moving
            case 0:
                currentMoveIsWhite = false;
                break;
            // if white is moving
            case 1:
                currentMoveIsWhite = true;
                break;
            // error if value of not 0 or 1 is used
            default:
                Message.errorMessage("Turn being set is invalid");
                break;
        }
    }
    
    /**
     * Tells is the current move is white or not
     * @return true if current move is white, false for black
     */
    public boolean getCurrentMove() {
        return currentMoveIsWhite;
    }
    
    /**
     * Changes the moving piece state values to ones that reflect that there is not piece currently moving/selected
     */
    public void resetMoving() {
        isMoving = false;
        moving = null;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        b00 = new gameboard.Square();
        b01 = new gameboard.Square();
        b02 = new gameboard.Square();
        b03 = new gameboard.Square();
        b04 = new gameboard.Square();
        b05 = new gameboard.Square();
        b06 = new gameboard.Square();
        b07 = new gameboard.Square();
        b14 = new gameboard.Square();
        b16 = new gameboard.Square();
        b10 = new gameboard.Square();
        b15 = new gameboard.Square();
        b11 = new gameboard.Square();
        b12 = new gameboard.Square();
        b17 = new gameboard.Square();
        b13 = new gameboard.Square();
        b24 = new gameboard.Square();
        b26 = new gameboard.Square();
        b20 = new gameboard.Square();
        b25 = new gameboard.Square();
        b21 = new gameboard.Square();
        b22 = new gameboard.Square();
        b27 = new gameboard.Square();
        b23 = new gameboard.Square();
        b34 = new gameboard.Square();
        b36 = new gameboard.Square();
        b30 = new gameboard.Square();
        b35 = new gameboard.Square();
        b31 = new gameboard.Square();
        b32 = new gameboard.Square();
        b37 = new gameboard.Square();
        b33 = new gameboard.Square();
        b44 = new gameboard.Square();
        b46 = new gameboard.Square();
        b40 = new gameboard.Square();
        b45 = new gameboard.Square();
        b41 = new gameboard.Square();
        b42 = new gameboard.Square();
        b47 = new gameboard.Square();
        b43 = new gameboard.Square();
        b54 = new gameboard.Square();
        b56 = new gameboard.Square();
        b50 = new gameboard.Square();
        b55 = new gameboard.Square();
        b51 = new gameboard.Square();
        b52 = new gameboard.Square();
        b57 = new gameboard.Square();
        b53 = new gameboard.Square();
        b64 = new gameboard.Square();
        b66 = new gameboard.Square();
        b60 = new gameboard.Square();
        b65 = new gameboard.Square();
        b61 = new gameboard.Square();
        b62 = new gameboard.Square();
        b67 = new gameboard.Square();
        b63 = new gameboard.Square();
        b74 = new gameboard.Square();
        b76 = new gameboard.Square();
        b70 = new gameboard.Square();
        b75 = new gameboard.Square();
        b71 = new gameboard.Square();
        b72 = new gameboard.Square();
        b77 = new gameboard.Square();
        b73 = new gameboard.Square();

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(b10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(b00, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b01, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b02, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b03, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b04, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b05, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b06, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b07, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                .addGroup(layout.createSequentialGroup()
                    .addComponent(b40, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b41, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b42, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b43, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b44, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b45, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b46, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b47, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createSequentialGroup()
                    .addComponent(b30, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b31, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b32, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b33, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b34, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b35, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b36, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b37, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createSequentialGroup()
                    .addComponent(b20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b22, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b23, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b24, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b25, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b26, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b27, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                .addGroup(layout.createSequentialGroup()
                    .addComponent(b60, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b61, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b62, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b63, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b64, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b65, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b66, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b67, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createSequentialGroup()
                    .addComponent(b50, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b51, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b52, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b53, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b54, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b55, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b56, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, 0)
                    .addComponent(b57, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
            .addGroup(layout.createSequentialGroup()
                .addComponent(b70, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b71, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b72, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b73, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b74, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b75, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b76, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(b77, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b00, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b01, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b02, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b03, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b04, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b05, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b06, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b07, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b11, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b12, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b13, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b14, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b15, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b16, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b17, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b20, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b21, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b22, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b23, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b24, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b25, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b26, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b27, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b30, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b31, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b32, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b33, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b34, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b35, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b36, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b37, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b40, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b41, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b42, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b43, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b44, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b45, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b46, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b47, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b50, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b51, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b52, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b53, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b54, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b55, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b56, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b57, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b60, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b61, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b62, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b63, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b64, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b65, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b66, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b67, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(b70, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b71, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b72, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b73, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b74, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b75, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b76, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b77, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
    }// </editor-fold>//GEN-END:initComponents

    // <editor-fold defaultstate="collapsed" desc="Initialize Board">
    /**
     * Initializes the board to the normal chess setup
     */
    private void initBoard() {
        // Initializes the 8x8 array of squares for chess game
        // uses the Square names set by the GUI editor and enters them into an array for access
        board = new Square[][] {
            {b00, b01, b02, b03, b04, b05, b06, b07}, 
            {b10, b11, b12, b13, b14, b15, b16, b17},
            {b20, b21, b22, b23, b24, b25, b26, b27},
            {b30, b31, b32, b33, b34, b35, b36, b37}, 
            {b40, b41, b42, b43, b44, b45, b46, b47},
            {b50, b51, b52, b53, b54, b55, b56, b57}, 
            {b60, b61, b62, b63, b64, b65, b66, b67}, 
            {b70, b71, b72, b73, b74, b75, b76, b77}
        };
        
        // sets the colors of the board (creates a checkered pattern)
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board.length; c++) {
                // if the row and column have the same divisibility by 2, set the square to the light color
                if (r % 2 == c % 2) {
                    board[r][c].getButton().setBackground(Square.LIGHT_WOOD);
                }
                // if the row and ccolumn do not have the same divisibility by 2, set the square to the dark color
                else {
                    board[r][c].getButton().setBackground(Square.DARK_WOOD);
                }
                // sets the parent of the square as this board
                board[r][c].setParent(this);
            }
        }
        
        // set up the piece objects and sprites
        setDefault();
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Set Default Board">
    /**
     * Sets the board to the default setup for chess
     */
    public void setDefault() {
        // set the current move to be the default (white)
        this.currentMoveIsWhite = true;
        if (!parent.isCurrentMoveLabelNull()) {
            parent.setCurrentMoveLabel(currentMoveIsWhite);
        }
        // no piece is selected
        isMoving = false;
        moving = null;
        
        // initialize the standard setup for chess pieces
        // left column is the back row of the black pieces, right is the back row of the white pieces
        board[0][0].setPiece(false, 4); board[7][0].setPiece(true, 4); 
        board[0][1].setPiece(false, 2); board[7][1].setPiece(true, 2); 
        board[0][2].setPiece(false, 3); board[7][2].setPiece(true, 3); 
        board[0][3].setPiece(false, 5); board[7][3].setPiece(true, 5); 
        board[0][4].setPiece(false, 6); board[7][4].setPiece(true, 6); 
        board[0][5].setPiece(false, 3); board[7][5].setPiece(true, 3); 
        board[0][6].setPiece(false, 2); board[7][6].setPiece(true, 2); 
        board[0][7].setPiece(false, 4); board[7][7].setPiece(true, 4); 
        
        // sets up the pawns' rows for both sides
        for (int i = 0; i < board[0].length; i++) {
            board[1][i].setPiece(false, 1);
            board[6][i].setPiece(true, 1);
        }
        
        // sets the rest of the board to be empty (unloads sprites so there is no piece graphic in the square)
        for (int r = 2; r < 6; r++) {
            for (int c = 0; c <  board[0].length; c++) {
                Piece s = board[r][c].getPiece();
                if (s != null) {
                    s.getSprite().unloadSprite(board[r][c].getButton());
                }
                board[r][c].setPiece(null);
            }
        }
        
        // enable the board for a new move to happen, in this case its the first move.
        newMoveEnabling();
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Setup for new move (newMoveEnabling)">
    /**
     * Enables and disables the board for use, depending on whether a square contains a piece
     */
    public void newMoveEnabling() {
        // enable all pieces that are of the current colors turn to be selectable
        // disable selection of all those that are not of the current colors turn
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c <  board[0].length; c++) {
                // if there is a piece in the square and it is of the current color's color
                if (board[r][c].getPiece() != null && board[r][c].getPiece().isWhite() == currentMoveIsWhite) {
                    board[r][c].setPanelEnabled(true);
                }
                // if its not, then disable
                else {
                    board[r][c].setPanelEnabled(false);
                }
            }
        }
        
        // set the undo label for the current turn for how many undos the current color has left
        parent.setUndoLabel();
        
        // check if the current player has been checkmated
        if (isCheckmate()) {
            // report to the user there is a checkmate
            parent.setCheckLabel("Checkmate!");
        }
        // check if the king is currently in check for the current color
        else if (isKingInCheck(currentMoveIsWhite, board)) {
            // report to the user that they are in check
            parent.setCheckLabel("Check!");
        }
        // check if there is a stalemate
        else if (isStalemate()) {
            // report to the user that a stalemate has occurred
            parent.setCheckLabel("Stalemate!");
        }
        // if none of the above conditions are true, then reset the label that would report information life check, checkmate, and stalemate to the user
        else if (!parent.isCheckLabelNull()) {
            parent.setCheckLabel("");
        }
        
        // check if the beginner setting is turned on. 
        // if it is, then only show pieces as selectable if they have possible moves
        if (parent.isBeginner()) {
            // parse through squares in the board
            for (int r = 0; r < board.length; r++) {
                for (int c = 0; c <  board[0].length; c++) {
                    // if the element selected has a piece and is of the current color's color and cannot move, disable the square from being selected
                    // above already covered other possibilities
                    if (board[r][c].getPiece() != null && board[r][c].getPiece().isWhite() == currentMoveIsWhite && !this.canMove(board[r][c])) {
                        board[r][c].setPanelEnabled(false);
                    }
                }
            }
        }
        
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Move">
    /**
     * Moves the currently selected piece to the location in destination.
     * The sprite in the current location is nullified and the destination gains the new sprite
     * If a piece is captured, it is moved to the graveyard
     * If a pawn is to be queened, it brings a modality panel
     * @param destination the place on the board where the selected piece will move to
     */
    public void moveToLocation(Square destination) {
        if (destination.isPanelEnabled() && destination != moving) {
            int captureID = 0;
            int x2 = destination.getPieceX();
            int x1 = moving.getPieceX();
            int y2 = destination.getPieceY();
            int y1 = moving.getPieceY();
            // add the piece being captured to the graveyard
            int enPassant = 0;
            if (destination.getPiece() != null) {
                captureID = destination.getPiece().getPieceID();
                parent.getGraveyard(destination.getPiece().isWhite()).add(destination.getPiece());
            }
            else {
                // check if the move was an En Passant and move accordingly
                enPassant = enPassant(moving.getPiece().getPieceID(), x1, y1, x2, y2);
                captureID = enPassant;
            }
            
            // move the piece to the destination
            destination.setPiece(moving.getPiece());
            
            // check if the move was a castle and move the rook accordingly
            boolean castled = castle(destination, x1, y1, y2);
            
            // set the original to null and unload the sprite currently loaded into the square
            moving.getPiece().getSprite().unloadSprite(moving.getButton());
            moving.setPiece(null);
            
            // queen piece if necessary
            int id = destination.getPiece().getPieceID();
            boolean queened = false;
            if ((id == 1 && isInRow(destination, 0)) || (id == 7 && isInRow(destination, 7))) {
                queened = true;
                queenPiece(destination);
            }
            
            // reset the state to no longer moving
            //      save move to log file if autosave and save current log
            if (parent.isAutosave()) {
                parent.saveLog(x1, y1, x2, y2, 
                        captureID, queened, castled, enPassant != 0, currentMoveIsWhite);
            }
            //      save move to log ArrayList if autosave is off
            else {
                parent.getLog().add(new Move(x1 + "," + y1 + "," + x2 + "," + y2 + "," + captureID + "," + queened
                        + "," + castled + "," + (enPassant != 0) + "," + currentMoveIsWhite));
            }
            
            //      get ready for next move
            isMoving = false;
            moving = null;
            currentMoveIsWhite = !currentMoveIsWhite;
            parent.setCurrentMoveLabel(currentMoveIsWhite);
            newMoveEnabling();
            
            // save if autosave is enabled
            if (parent.isAutosave()) {
                parent.save();
            }
        }
        else if (destination == moving) {
            isMoving = false;
            moving = null;
            newMoveEnabling();
        }
    }
    
    /**
     * Takes a parameter of a Square and selects it, 
     * showing the legal moves that it can make (enabled the board in those places)
     * @param pieceMoving The square containing the piece that is moving
     */
    public void setupForMove(Square pieceMoving) {
        if (pieceMoving.isPanelEnabled()) {
            boolean[][] moveset = pieceMoving.getPiece().getMoveSet(board);
            for (int r = 0; r < moveset.length; r++) {
                for (int c = 0; c < moveset.length; c++) {
                    // check if king is in check
                    if (isKingInCheck(pieceMoving.getPiece().isWhite(), board)) {
                        // check if possible move takes the king out of check, if it does, enable the square
                        if (moveset[r][c] && takesOutOfCheck(pieceMoving, board[r][c], board)) {
                            board[r][c].setPanelEnabled(true);
                        }
                        // if it does not, disable the square
                        else {
                            board[r][c].setPanelEnabled(false);
                        }
                    }
                    else {
                        // check if the move puts the king into check
                        // if so, disable the move from happening
                        if (moveset[r][c] && board[r][c] != null && !takesOutOfCheck(pieceMoving, board[r][c], board)) {
                            board[r][c].setPanelEnabled(false);
                        }
                        // otherwise set the squares enabled status to whether or not the move to the square is legal under normal circumstances
                        else {
                            board[r][c].setPanelEnabled(moveset[r][c]);
                        }
                    }
                }
            }
            
            // enable squares for castling if applicable
            final int row = (pieceMoving.getPiece().isWhite()) ? 7: 0;
            final int col = 4;
            final int kingID = (pieceMoving.getPiece().isWhite()) ? Piece.KING_ID: Piece.KING_ID + 6;
            // if the piece at the current color's starting king position is a king and it is moving
            if (board[row][col] == pieceMoving && board[row][col].getPiece().getPieceID() == kingID) {
                // if the king is legally allowed to castle to the right, enable the square 2 to the right of the king for selection of move
                board[row][col+2].setPanelEnabled(board[row][col].getPiece().canCastle(board, true));
                // if the king is legally allowed to castle to the left, enable the square 2 to the left of the king for selection of move
                board[row][col-2].setPanelEnabled(board[row][col].getPiece().canCastle(board, false));
            }
            
            // setup the currently moving piece to the selected piece
            moving = pieceMoving;
            moving.setBackground(Square.MOVING);
            moving.setForeground(Square.MOVING);
            isMoving = true;
        }
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Queen a Piece">
    /**
     * Brings up a modality panel where the user can choose what piece they would like to make the pawn being queened into
     * @param s A square containing a piece to be queened (should be a pawn, but works with other types)
     */
    public void queenPiece(Square s) {
        ModalityPanel queener = new ModalityPanel(parent, s.getPiece().isWhite(), s);
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Castle">
    private boolean castle(Square destination, int x1, int y1, int y2) {
        int kingID  = (destination.getPiece().isWhite()) ? Piece.KING_ID: Piece.KING_ID + 6;
        // if the piece that moved was a king
        if (destination.getPiece().getPieceID() == kingID) {
            int x = x1;
            int y = y1;
            int coordCheck = (destination.getPiece().isWhite()) ? 7: 0;
            // if the move was a castle, move the corresponding rook
            if (x == coordCheck && y == 4) {
                int newY = y2;
                int rookID = (destination.getPiece().isWhite()) ? Piece.ROOK_ID: Piece.ROOK_ID + 6;
                // if the move was to the right
                if (newY == y+2) {
                    if (board[x][7].getPiece() != null && board[x][7].getPiece().getPieceID() == rookID) {
                        board[x][newY-1].setPiece(board[x][7].getPiece());
                        board[x][7].getPiece().getSprite().unloadSprite(board[x][7].getButton());
                        board[x][7].setPiece(null);
                    }
                }
                // else if the move was to the left
                else if (newY == y-2) {
                    if (board[x][0].getPiece() != null && board[x][0].getPiece().getPieceID() == rookID) {
                        board[x][newY+1].setPiece(board[x][0].getPiece());
                        board[x][0].getPiece().getSprite().unloadSprite(board[x][0].getButton());
                        board[x][0].setPiece(null);
                    }
                }
                return true;
            }
        }
        return false;
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="En Passant">
    /**
     * Tells whether a move is an enPassant.  If it is, then the piece that would be captured is captured.
     * Precondition: Move is not capturing
     * @param movingID the id of the piece that is moving
     * @param x1 the original row of the piece moving
     * @param y1 the original column of the piece moving
     * @param x2 the final row of the piece moving
     * @param y2 the final column of the pice moving
     * @return Returns the capture id of the piece captured, if there was no en passant, returns 0.
     *         Method only returns 0,1, or 7
     */
    private int enPassant(int movingID, int x1, int y1, int x2, int y2) {
        // if the piece moving is a pawn and white
        if (movingID == 1) {
            if (x1 == x2 + 1 && (y1 == y2 + 1 || y1 == y2 - 1)) {
                if (board[x1][y2].getPiece() != null || board[x1][y2].getPiece().getPieceID() == 7) {
                    // add captured black pawn to graveyard
                    parent.getGraveyard(false).add(board[x1][y2].getPiece());
                    // unload sprite
                    board[x1][y2].getPiece().getSprite().unloadSprite(board[x1][y2].getButton());
                    // remove piece
                    board[x1][y2].setPiece(null);
                    return 7;
                }
                else {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        // if the piece moving is a pawn and black
        else if (movingID == 7) {
            if (x1 == x2 - 1 && (y1 == y2 + 1 || y1 == y2 - 1)) {
                if (board[x1][y2].getPiece() != null || board[x1][y2].getPiece().getPieceID() == 1) {
                    // add captured white pawn to graveyard
                    parent.getGraveyard(true).add(board[x1][y2].getPiece());
                    // unload sprite
                    board[x1][y2].getPiece().getSprite().unloadSprite(board[x1][y2].getButton());
                    // remove piece
                    board[x1][y2].setPiece(null);
                    return 1;
                }
                else {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        // if the piece is not a pawn
        else {
            return 0;
        }
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Is Square in Row">
    /**
     * Checks if the Square s is in the row row on the board
     * @param s the square to see if it is in the specified row
     * @param row the row to see if the square is in
     * @return true if the row contains the square, false otherwise.
     */
    public boolean isInRow(Square s, int row) {
        for (int i = 0; i < board[row].length; i++) {
            if (board[row][i] == s) {
                return true;
            }
        }
        return false;
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Check">
    /**
     * Checks if a move puts the king in check
     * @param origin the square that the piece is moving from
     * Precondition: The piece in the origin square must not be null (returns false if it is)
     * @param destination the square that the piece is moving into
     * @param board the board that both origin and destination lie on
     * @return true if the king would be put in check by the move, false otherwise
     */
    public static boolean putsInCheck(Square origin, Square destination, Square[][] board) {
        // checks to make sure the starting point has a piece, otherwise the move wouldn't do anything because it isnt a move...
        if (origin.getPiece() == null) {
            return false;
        }
        
        // creates temporary holders for the pieces to be put back after checking hypothetical move
        Piece destinationHolder = destination.getPiece();
        Piece originHolder = origin.getPiece();
        
        // moves the starting piece to the location (does not change sprites because this is only temporary, user doesnt see it)
        // starting point is nullified for now
        origin.setPiece(null, false);
        destination.setPiece(originHolder, false);
        
        // gets the moveset from the piece at its destination
        boolean[][] moveset = destination.getPiece().getMoveSet(board);
        // if the king of the opposite color is the moveset, return true
        for (int r = 0; r < moveset.length; r++) {
            for (int c = 0; c < moveset[0].length; c++) {
                Piece p = board[r][c].getPiece();
                // if the piece can move to the current selection and that selection contains a piece
                if (moveset[r][c] && p != null) {
                    // the id of the currently selected piece
                    int id = p.getPieceID();
                    
                    // the id of the king of the opposite color from the piece moving (6 if white, 12 if black)
                    int kingID = (board[r][c].getPiece().isWhite()) ? Piece.KING_ID: Piece.KING_ID + 6;
                    
                    // checks if the id of the selected piece is the kind of its color
                    if (id == kingID) {
                        // move pieces back to original locations and return that the king is in check
                        destination.setPiece(destinationHolder, false);
                        origin.setPiece(originHolder, false);
                        // returns true that the king is in check
                        return true;
                    }
                }
            }
        }
        // move the pieces back to their original locations
        destination.setPiece(destinationHolder, false);
        origin.setPiece(originHolder, false);
        // else return false as the king is not in check
        return false;
    }
    
    /**
     * Checks if the current position of a piece is putting the king in check
     * @param origin the square that the piece to check if it is putting the king in check
     * @param board the board that the Square origin lies on
     * @return true if the king is being put in check by the piece, false otherwise
     */
    public static boolean putsInCheck(Square origin, Square[][] board) {
        // checks to make sure the starting point has a piece, otherwise the move wouldn't do anything because it isnt a move...
        if (origin.getPiece() == null) {
            return false;
        }
        
        boolean[][] moveset = origin.getPiece().getMoveSet(board);
        // if the king of the opposite color is the moveset, return true
        for (int r = 0; r < moveset.length; r++) {
            for (int c = 0; c < moveset[0].length; c++) {
                Piece p = board[r][c].getPiece();
                // if the piece can move to the current selection and that selection contains a piece
                if (moveset[r][c] && p != null) {
                    // the id of the currently selected piece
                    int id = p.getPieceID();
                    
                    // the id of the king of the opposite color from the piece moving (6 if white, 12 if black)
                    int kingID = (p.isWhite()) ? Piece.KING_ID: Piece.KING_ID + 6;
                    
                    // checks if the id of the selected piece is the kind of its color
                    if (id == kingID) {
                        // returns true that the king is in check
                        return true;
                    }
                }
            }
        }
        // else returns false as the king is not in check
        return false;
    }
    
    /**
     * Checks to see if any piece is putting the king in check
     * @param isTurnWhite the current turn color, true for white, false for black
     * @param board the board to check if the king of color isTurnWhite is in check
     * @return true if the king is in check, false otherwise
     */
    public static boolean isKingInCheck(boolean isTurnWhite, Square[][] board) {
        for (int r = 0; r <  board.length; r++) {
            for (int c = 0; c < board[0].length; c++) {
                // if the selected piece is not null and it is a different color than the current turn
                if (board[r][c].getPiece() != null && board[r][c].getPiece().isWhite() != isTurnWhite) {
                    // if the selected piece is putting the king in check, return true
                    if (putsInCheck(board[r][c], board)) {
                        return true;
                    }
                }
            }
        }
        // no pieces were found to be putting the king in check, so return false
        return false;
    }
    
    /**
     * Checks if the hypothetical move from Square origin to Square destination takes the king out of check
     * If the method returns false, that would mean the piece is putting or puts the king into check.
     * The method moves the piece in origin to destination and calls isKingInCheck, returning the opposite value
     * Before returning, the method switches the pieces back to where they were
     * @param origin the starting point of the piece
     * @param destination the ending point of the piece
     * @param board the board that the pieces/squares reside on
     * @return true if the move takes the king out of check, false otherwise
     */
    public static boolean takesOutOfCheck(Square origin, Square destination, Square[][] board) {
        // checks to make sure the starting point has a piece, otherwise the move wouldn't do anything because it isnt a move...
        if (origin.getPiece() == null) {
            return false;
        }
        
        // creates temporary holders for the pieces to be put back after checking hypothetical move
        Piece destinationHolder = destination.getPiece();
        Piece originHolder = origin.getPiece();
        
        // moves the starting piece to the location (does not change sprites because this is only temporary, user doesnt see it)
        // starting point is nullified for now
        origin.setPiece(null, false);
        destination.setPiece(originHolder, false);
        
        // Finds the return value - if the king is in check its false, true otherwise
        boolean rtn = !isKingInCheck(destination.getPiece().isWhite(), board);
        
        // move the pieces back to their original locations
        destination.setPiece(destinationHolder, false);
        origin.setPiece(originHolder, false);
        // else return false as the king is not in check
        return rtn;
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Checkmate">
    /**
     * Checks if the piece specified in pieceMoving has any legal moves
     * @param pieceMoving the piece that is to be tested for its ability to move
     * @return true if the piece has possible moves, false otherwise
     */
    public boolean canMove(Square pieceMoving) {
        if (pieceMoving.isPanelEnabled()) {
            boolean[][] moveset = pieceMoving.getPiece().getMoveSet(board);
            for (int r = 0; r < moveset.length; r++) {
                for (int c = 0; c < moveset.length; c++) {
                    // if the king is currently in check
                    if (isKingInCheck(pieceMoving.getPiece().isWhite(), board)) {
                        // check to make sure the move would take the king out of check
                        if (moveset[r][c] && takesOutOfCheck(pieceMoving, board[r][c], board)) {
                            return true;
                        }
                    }
                    // if the king is not in check
                    else {
                        // check to make sure the move would not put the king into check
                        if (moveset[r][c] && board[r][c] != null && takesOutOfCheck(pieceMoving, board[r][c], board)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    
    /**
     * Checks if the side on the current move is in checkmate
     * @return true if checkmate, false otherwise
     */
    public boolean isCheckmate() {
        if (isKingInCheck(currentMoveIsWhite, board)) {
            // parse through the board to see if any pieces of the current color can move
            // if they can, return false as it is not checkmate
            for (int r = 0; r < board.length; r++) {
                for (int c = 0; c < board.length; c++) {
                    if (board[r][c].getPiece() != null 
                            && board[r][c].getPiece().isWhite() == currentMoveIsWhite 
                            && canMove(board[r][c])) {
                        return false;
                    }
                }
            }
            // if not pieces are found that can move, it is checkmate, return as such
            return true;
        }
        else return false;
    }
    // </editor-fold>
    
    // <editor-fold defaultstate="collapsed" desc="Stalemate">
    /**
     * Checks if the side on the current move is in stalemate.
     * @return true if stalemate, false otherwise
     */
    public boolean isStalemate() {
        // check to make sure the king is not in check
        if (!isKingInCheck(currentMoveIsWhite, board)) {
            // parse through the board to see if any pieces of the current color can move
            // if they can, return false as it is not stalemate
            for (int r = 0; r < board.length; r++) {
                for (int c = 0; c < board.length; c++) {
                    if (board[r][c].getPiece() != null 
                            && board[r][c].getPiece().isWhite() == currentMoveIsWhite 
                            && canMove(board[r][c])) {
                        return false;
                    }
                }
            }// if not pieces are found that can move, it is stalemate, return as such
            return true;
        }
        else return false;
    }
    // </editor-fold>

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private gameboard.Square b00;
    private gameboard.Square b01;
    private gameboard.Square b02;
    private gameboard.Square b03;
    private gameboard.Square b04;
    private gameboard.Square b05;
    private gameboard.Square b06;
    private gameboard.Square b07;
    private gameboard.Square b10;
    private gameboard.Square b11;
    private gameboard.Square b12;
    private gameboard.Square b13;
    private gameboard.Square b14;
    private gameboard.Square b15;
    private gameboard.Square b16;
    private gameboard.Square b17;
    private gameboard.Square b20;
    private gameboard.Square b21;
    private gameboard.Square b22;
    private gameboard.Square b23;
    private gameboard.Square b24;
    private gameboard.Square b25;
    private gameboard.Square b26;
    private gameboard.Square b27;
    private gameboard.Square b30;
    private gameboard.Square b31;
    private gameboard.Square b32;
    private gameboard.Square b33;
    private gameboard.Square b34;
    private gameboard.Square b35;
    private gameboard.Square b36;
    private gameboard.Square b37;
    private gameboard.Square b40;
    private gameboard.Square b41;
    private gameboard.Square b42;
    private gameboard.Square b43;
    private gameboard.Square b44;
    private gameboard.Square b45;
    private gameboard.Square b46;
    private gameboard.Square b47;
    private gameboard.Square b50;
    private gameboard.Square b51;
    private gameboard.Square b52;
    private gameboard.Square b53;
    private gameboard.Square b54;
    private gameboard.Square b55;
    private gameboard.Square b56;
    private gameboard.Square b57;
    private gameboard.Square b60;
    private gameboard.Square b61;
    private gameboard.Square b62;
    private gameboard.Square b63;
    private gameboard.Square b64;
    private gameboard.Square b65;
    private gameboard.Square b66;
    private gameboard.Square b67;
    private gameboard.Square b70;
    private gameboard.Square b71;
    private gameboard.Square b72;
    private gameboard.Square b73;
    private gameboard.Square b74;
    private gameboard.Square b75;
    private gameboard.Square b76;
    private gameboard.Square b77;
    // End of variables declaration//GEN-END:variables
}
